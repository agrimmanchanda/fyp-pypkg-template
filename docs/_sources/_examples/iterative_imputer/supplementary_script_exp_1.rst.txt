
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "_examples\iterative_imputer\supplementary_script_exp_1.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download__examples_iterative_imputer_supplementary_script_exp_1.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr__examples_iterative_imputer_supplementary_script_exp_1.py:


Iterative Imputer Supplementary Script 1
===========================================

The following script is a supplementary script 
which was developed during the project. The methodology was 
initially manually implemented to understand individual steps
but was later automatically done.

.. GENERATED FROM PYTHON SOURCE LINES 13-16

-------------------------------------
Libraries import 
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 16-37

.. code-block:: default
   :lineno-start: 17


    import numpy as np 
    import pandas as pd
    import matplotlib.pyplot as plt
    from sklearn.model_selection import KFold
    from sklearn.linear_model import BayesianRidge
    from sklearn.tree import DecisionTreeRegressor
    from sklearn.ensemble import ExtraTreesRegressor
    from sklearn.neighbors import KNeighborsRegressor
    from sklearn.ensemble import RandomForestRegressor
    from sklearn.linear_model import SGDRegressor
    from sklearn.neural_network import MLPRegressor
    from xgboost import XGBRegressor
    from sklearn.experimental import enable_iterative_imputer
    from sklearn.impute import IterativeImputer
    from sklearn.impute import SimpleImputer
    from sklearn import preprocessing
    import warnings
    warnings.filterwarnings("ignore")
    from labimputer.utils.iter_imp import *


.. GENERATED FROM PYTHON SOURCE LINES 38-41

-------------------------------------
Data import 
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 41-54

.. code-block:: default
   :lineno-start: 42


    # Set relative data path and set FBC panel list
    path_data = '../resources/datasets/nhs/Transformed_First_FBC_dataset.csv'

    FBC_CODES = sorted(["EOS", "MONO", "BASO", "NEUT", "RBC", "WBC", 
                    "MCHC", "MCV", "LY", "HCT", "RDW", "HGB", 
                    "MCH", "PLT", "MPV", "NRBCA"])

    # Read data and drop Nan _uid records
    df = pd.read_csv(path_data).dropna(subset=['pid'])

    df.reset_index(drop=True, inplace=True)


.. GENERATED FROM PYTHON SOURCE LINES 55-58

-------------------------------------
Remove outliers from dataset
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 58-71

.. code-block:: default
   :lineno-start: 59


    # Obtain the biomarkers DataFrame with outliers
    biomarkers_df = df[FBC_CODES].dropna(subset=FBC_CODES)

    # Make dataset copy
    biomarkers_original_df_copy = biomarkers_df.copy(deep=True)

    # Store column names
    cols = [col for col in biomarkers_df.columns]

    # Convert to array for processing 
    biomarkers_data = biomarkers_df.values


.. GENERATED FROM PYTHON SOURCE LINES 72-75

-------------------------------------
Biomarker correlations
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 75-89

.. code-block:: default
   :lineno-start: 76


    # Obtain highest correlation pairs Pearson Correlation Coefficient
    biomarkers_highest_corr = corr_pairs(biomarkers_df)

    # Find biomarkers that are to be dropped from the dataset
    biomarkers_to_drop = np.unique(biomarkers_highest_corr[['var1', 'var2']].values)

    print("\nBiomarkers with high correlations: ", biomarkers_to_drop)

    # DataFrame to store all experiment MSE scores
    rmse_score_df = pd.DataFrame(index=biomarkers_df.columns)
    rmse_score_df.index.names = ['Biomarker']
    rmsle_score_df = rmse_score_df.copy(deep=True)


.. GENERATED FROM PYTHON SOURCE LINES 90-93

-------------------------------------
K-Fold Cross Validation (K = 5)
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 93-105

.. code-block:: default
   :lineno-start: 94


    # Define min-max scaler and normalise dataset
    min_max_scaler = preprocessing.StandardScaler()

    # Initialise 5-Fold cross validation
    kf5 = KFold(n_splits=5, shuffle=False, random_state=None)

    # Temporary mse_score_df to store mse score for each fold
    temp_rmse_score_df = rmse_score_df.copy(deep=True)
    temp_rmsle_score_df = rmse_score_df.copy(deep=True)



.. GENERATED FROM PYTHON SOURCE LINES 106-109

-------------------------------------
Define estimators 
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 109-126

.. code-block:: default
   :lineno-start: 110


    estimators = {
        'Bayesian Ridge': BayesianRidge(),
        'Decision Tree': DecisionTreeRegressor(),
        'Random Forest': ExtraTreesRegressor(),
        'XGBoost': XGBRegressor(),
        'K-NN': KNeighborsRegressor(weights='distance'),
        'Least Squares (SGD)': SGDRegressor(loss='squared_loss', 
        early_stopping=True),
        'Huber (SGD)': SGDRegressor(loss='huber', early_stopping=True),
        'Support Vector (SGD)': SGDRegressor(loss='epsilon_insensitive', 
        early_stopping=True),
        'MLP': MLPRegressor(hidden_layer_sizes=32, 
        early_stopping=True, max_iter=100),
        'Simple Median': SimpleImputer(strategy='median'),
    }


.. GENERATED FROM PYTHON SOURCE LINES 127-130

-------------------------------------
Predict values using imputer 
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 130-198

.. code-block:: default
   :lineno-start: 131


    # Run 5-fold CV for each estimator method
    for method, imputer_estimator in estimators.items():
        for k, (train_idx, test_idx) in enumerate(kf5.split(biomarkers_data)):

            # Obtain 1-fold test and 4-fold train sets 
            train_df = biomarkers_df.iloc[train_idx]
            val_scaled =  min_max_scaler.fit(train_df)
            train_scaled = val_scaled.transform(train_df)
            train_scaled_df = pd.DataFrame(train_scaled)
            train_scaled_copy_df = train_scaled_df.copy(deep=True)
        
            test_df = biomarkers_df.iloc[test_idx]
            test_df.columns = [x for x in range(test_df.shape[1])]
            test_scaled = val_scaled.transform(test_df)
            test_scaled_df = pd.DataFrame(test_scaled)
            test_scaled_copy_df = test_scaled_df.copy(deep=True)

            # Define imputer
            if method == 'Simple Median':
                imputer = imputer_estimator
            else:
                imputer = IterativeImputer(estimator=imputer_estimator)
        
            # Fit on the dataset
            trained_imputer = imputer.fit(train_scaled_df)

            # Test each biomarker independently
            for biomarker in test_scaled_df.columns:

                # Use a clean copy of the normalised data set
                test_with_nan = test_scaled_df.copy(deep=True)

                # Strictly set every biomarker value to NaN
                col_pos = test_with_nan.columns.get_loc(biomarker)
                test_with_nan.iloc[::1, col_pos] = np.nan

                # Transform test data using trained imputer
                test_transformed_data = trained_imputer.transform(test_with_nan)

                # Make dataframe of imputed data
                imputed_data = pd.DataFrame(data=test_transformed_data, 
                index=[i for i in range(test_transformed_data.shape[0])], 
                columns=test_scaled_df.columns)

                # Inverse transform the scaled values
                test_og_data = abs(val_scaled.inverse_transform(imputed_data))

                imputed_data_og = pd.DataFrame(data=test_og_data,
                index=[i for i in range(test_transformed_data.shape[0])], 
                columns=test_scaled_df.columns)

                # Compute true and obtain real value
                val_pred = imputed_data_og[biomarker].values
                val_true = test_df[biomarker].values

                # Calculate MSE scores from the true and predicted values
                rmse_score = get_metric_scores(val_true, val_pred, 'RMSE')
                rmsle_score = get_metric_scores(val_true, val_pred, 'RMSLE')

                # Store in temp_mse_score_df and temp_rmsle_score_df 
                temp_rmse_score_df.loc[temp_rmse_score_df.index[biomarker], f'K-Fold: {k+1}'] = rmse_score
                temp_rmsle_score_df.loc[temp_rmsle_score_df.index[biomarker], f'K-Fold: {k+1}'] = rmsle_score
    
        # Calculate mean MSE score for each biomarker across the 5-folds
        rmse_score_df[f'{method}'] = temp_rmse_score_df.mean(axis=1)
        rmsle_score_df[f'{method}'] = temp_rmsle_score_df.mean(axis=1)


.. GENERATED FROM PYTHON SOURCE LINES 199-202

-------------------------------------
Table of Results: RMSE
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 202-205

.. code-block:: default
   :lineno-start: 203


    rmse_score_df


.. GENERATED FROM PYTHON SOURCE LINES 206-209

-------------------------------------
Table of Results: RMSlE
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 209-212

.. code-block:: default
   :lineno-start: 210


    rmsle_score_df


.. GENERATED FROM PYTHON SOURCE LINES 213-216

-------------------------------------
Combined RMSE Plot for each biomarker
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 216-226

.. code-block:: default
   :lineno-start: 217


    # Plot horizontal bar graph 
    for biomarker, scores in rmse_score_df.iterrows():
        plt.figure(figsize=(20,15))
        plt.title(f'RMSE Scores for Biomarker: {biomarker} with Different Iterative Imputation Methods', fontweight='bold', fontsize=25)
        cmap = ['green' if (x == min(scores)) else 'blue' for x in scores]
        scores.plot.barh(grid=True, color=cmap)
        plt.xticks(fontsize=18)
        plt.yticks(fontsize=18)
        plt.xlabel('RMSE Score', fontsize=18)
        plt.show()

.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.000 seconds)


.. _sphx_glr_download__examples_iterative_imputer_supplementary_script_exp_1.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: supplementary_script_exp_1.py <supplementary_script_exp_1.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: supplementary_script_exp_1.ipynb <supplementary_script_exp_1.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
